// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: CRSLExplore.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// poi类型及释义
public enum CRSPoiType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///兴趣点（默认）
  case poiStar // = 0

  ///补给，水，食物
  case poiSupply // = 1

  ///终点，集合点
  case poiEnd // = 2

  ///签到点，分段点
  case poiCp // = 3

  ///停车，休息点，补给点
  case poiPark // = 4

  ///山顶，雪山
  case poiHill // = 5

  ///景点，记录，拍照
  case poiPhoto // = 6

  ///休息，露营，帐篷
  case poiTent // = 7

  ///森林，丛林，密集区域
  case poiForest // = 8

  ///危险，警示点，注意
  case poiHazard // = 9

  ///房子，建筑类
  case poiHome // = 10

  ///雪，雪上运动，冰冷
  case poiSnow // = 11

  ///路亚，中鱼点，钓鱼点
  case poiFish // = 12

  ///喜欢，收藏，标记
  case poiLike // = 13

  ///高空，空中运动，跳伞
  case poiHigh // = 14

  ///道路，转弯，路况
  case poiRoad // = 15

  ///起点
  case poiStart // = 16

  ///湖，湖泊，水上运动
  case poiRiver // = 17

  ///动物，危险，脚印
  case poiFootprint // = 18

  ///标点（默认）
  case poiPin // = 19

  /// 树枝
  case poiBranch // = 20

  /// 立草
  case poiReed // = 21

  /// 浮萍
  case poiDuckweed // = 22

  /// 暗礁
  case poiReef // = 23

  /// 断层
  case poiFault // = 24

  /// 滑坡
  case poiLandslide // = 25

  /// 铧尖
  case poiCape // = 26

  /// 码头
  case poiDock // = 27

  /// 桥墩
  case poiPier // = 28

  /// 语音
  case poiVoice // = 29

  ///途经点/端点
  case poiWaypoint // = 255
  case UNRECOGNIZED(Int)

  public init() {
    self = .poiStar
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .poiStar
    case 1: self = .poiSupply
    case 2: self = .poiEnd
    case 3: self = .poiCp
    case 4: self = .poiPark
    case 5: self = .poiHill
    case 6: self = .poiPhoto
    case 7: self = .poiTent
    case 8: self = .poiForest
    case 9: self = .poiHazard
    case 10: self = .poiHome
    case 11: self = .poiSnow
    case 12: self = .poiFish
    case 13: self = .poiLike
    case 14: self = .poiHigh
    case 15: self = .poiRoad
    case 16: self = .poiStart
    case 17: self = .poiRiver
    case 18: self = .poiFootprint
    case 19: self = .poiPin
    case 20: self = .poiBranch
    case 21: self = .poiReed
    case 22: self = .poiDuckweed
    case 23: self = .poiReef
    case 24: self = .poiFault
    case 25: self = .poiLandslide
    case 26: self = .poiCape
    case 27: self = .poiDock
    case 28: self = .poiPier
    case 29: self = .poiVoice
    case 255: self = .poiWaypoint
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .poiStar: return 0
    case .poiSupply: return 1
    case .poiEnd: return 2
    case .poiCp: return 3
    case .poiPark: return 4
    case .poiHill: return 5
    case .poiPhoto: return 6
    case .poiTent: return 7
    case .poiForest: return 8
    case .poiHazard: return 9
    case .poiHome: return 10
    case .poiSnow: return 11
    case .poiFish: return 12
    case .poiLike: return 13
    case .poiHigh: return 14
    case .poiRoad: return 15
    case .poiStart: return 16
    case .poiRiver: return 17
    case .poiFootprint: return 18
    case .poiPin: return 19
    case .poiBranch: return 20
    case .poiReed: return 21
    case .poiDuckweed: return 22
    case .poiReef: return 23
    case .poiFault: return 24
    case .poiLandslide: return 25
    case .poiCape: return 26
    case .poiDock: return 27
    case .poiPier: return 28
    case .poiVoice: return 29
    case .poiWaypoint: return 255
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CRSPoiType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CRSPoiType] = [
    .poiStar,
    .poiSupply,
    .poiEnd,
    .poiCp,
    .poiPark,
    .poiHill,
    .poiPhoto,
    .poiTent,
    .poiForest,
    .poiHazard,
    .poiHome,
    .poiSnow,
    .poiFish,
    .poiLike,
    .poiHigh,
    .poiRoad,
    .poiStart,
    .poiRiver,
    .poiFootprint,
    .poiPin,
    .poiBranch,
    .poiReed,
    .poiDuckweed,
    .poiReef,
    .poiFault,
    .poiLandslide,
    .poiCape,
    .poiDock,
    .poiPier,
    .poiVoice,
    .poiWaypoint,
  ]
}

#endif  // swift(>=4.2)

/// 操作类型
public enum CRSEventType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 增加新的点
  case add // = 0

  /// 实线点变编辑中的虚线点
  case clean // = 1

  /// 编辑中的虚线点变虚线点   
  case cleaned // = 2

  /// 删除
  case delete // = 3

  /// 插入
  case insert // = 4

  /// 倒序
  case invert // = 5

  /// 添加起点
  case addStart // = 6

  /// 删除起点
  case delStart // = 7

  /// 添加终点
  case addEnd // = 8

  /// 删除终点
  case delEnd // = 9

  /// 添加兴趣点
  case addPoi // = 10

  /// 删除兴趣点
  case delPoi // = 11

  /// 添加标点
  case addPosition // = 12

  /// 删除标点
  case delPosition // = 13

  /// 选中
  case select // = 14
  case UNRECOGNIZED(Int)

  public init() {
    self = .add
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .add
    case 1: self = .clean
    case 2: self = .cleaned
    case 3: self = .delete
    case 4: self = .insert
    case 5: self = .invert
    case 6: self = .addStart
    case 7: self = .delStart
    case 8: self = .addEnd
    case 9: self = .delEnd
    case 10: self = .addPoi
    case 11: self = .delPoi
    case 12: self = .addPosition
    case 13: self = .delPosition
    case 14: self = .select
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .add: return 0
    case .clean: return 1
    case .cleaned: return 2
    case .delete: return 3
    case .insert: return 4
    case .invert: return 5
    case .addStart: return 6
    case .delStart: return 7
    case .addEnd: return 8
    case .delEnd: return 9
    case .addPoi: return 10
    case .delPoi: return 11
    case .addPosition: return 12
    case .delPosition: return 13
    case .select: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CRSEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CRSEventType] = [
    .add,
    .clean,
    .cleaned,
    .delete,
    .insert,
    .invert,
    .addStart,
    .delStart,
    .addEnd,
    .delEnd,
    .addPoi,
    .delPoi,
    .addPosition,
    .delPosition,
    .select,
  ]
}

#endif  // swift(>=4.2)

/// 注释点的类型
public enum CRSAnnotationPointType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 起始点
  case start // = 0

  /// 终点
  case end // = 1

  /// 兴趣点
  case poi // = 2

  /// 位置点
  case position // = 3

  /// 可编辑点
  case edit // = 4

  /// 折返点
  case corner // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .start
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .start
    case 1: self = .end
    case 2: self = .poi
    case 3: self = .position
    case 4: self = .edit
    case 5: self = .corner
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .start: return 0
    case .end: return 1
    case .poi: return 2
    case .position: return 3
    case .edit: return 4
    case .corner: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CRSAnnotationPointType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CRSAnnotationPointType] = [
    .start,
    .end,
    .poi,
    .position,
    .edit,
    .corner,
  ]
}

#endif  // swift(>=4.2)

/// 路径点的类型
public enum CRSRoutePointStyle: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 实线点
  case solid // = 0

  /// 虚线点
  case dotted // = 1

  /// 拖动点
  case editing // = 2

  /// 擦除点
  case deleting // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .solid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .solid
    case 1: self = .dotted
    case 2: self = .editing
    case 3: self = .deleting
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .solid: return 0
    case .dotted: return 1
    case .editing: return 2
    case .deleting: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CRSRoutePointStyle: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CRSRoutePointStyle] = [
    .solid,
    .dotted,
    .editing,
    .deleting,
  ]
}

#endif  // swift(>=4.2)

/// 当前操作所属模式
public enum CRSActionMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 默认
  case normal // = 0

  /// 两点连线-匹配跑步
  case matchWalk // = 1

  /// 两点连线-匹配骑行
  case matchCycle // = 2

  /// 自由绘制-两点连线
  case pointFree // = 3

  /// 自由绘制-手绘
  case drawFree // = 4

  /// 标记位置
  case markPosition // = 5

  /// 开启擦除
  case cleanPath // = 6

  /// 擦除待确认
  case cleanedPath // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .normal
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .matchWalk
    case 2: self = .matchCycle
    case 3: self = .pointFree
    case 4: self = .drawFree
    case 5: self = .markPosition
    case 6: self = .cleanPath
    case 7: self = .cleanedPath
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .normal: return 0
    case .matchWalk: return 1
    case .matchCycle: return 2
    case .pointFree: return 3
    case .drawFree: return 4
    case .markPosition: return 5
    case .cleanPath: return 6
    case .cleanedPath: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CRSActionMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CRSActionMode] = [
    .normal,
    .matchWalk,
    .matchCycle,
    .pointFree,
    .drawFree,
    .markPosition,
    .cleanPath,
    .cleanedPath,
  ]
}

#endif  // swift(>=4.2)

public enum CRSTurnByTurnMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case tbtUnknow // = 0

  /// 直行向前 Turn straight
  case ts // = 1

  /// 向右前 Turn slight right
  case tlr // = 2

  /// 向右 Turn right
  case tr // = 3

  /// 向右后 Turn sharp right
  case tsr // = 4

  /// 直行调头 U-Turn
  case tu // = 5

  /// 向左后 Turn sharp left
  case tsl // = 6

  /// 向左 Turn left
  case tl // = 7

  /// 向左前 Turn slight left
  case tll // = 8

  /// 路口向左 Turn left at the fork
  case tfl // = 9

  /// 路口向右 Turn right at the fork
  case tfr // = 10

  /// 环形路口转弯 Roundabout
  case roundabout // = 11

  /// 右侧通行环形路口最终出口方向是直行
  case rarTs // = 12

  /// 右侧通行环形路口最终出口方向是向右前
  case rarTlr // = 13

  /// 右侧通行环形路口最终出口方向是向右
  case rarTr // = 14

  /// 右侧通行环形路口最终出口方向是向右后
  case rarTsr // = 15

  /// 右侧通行环形路口最终出口方向是调头
  case rarTu // = 16

  /// 右侧通行环形路口最终出口方向是向左后
  case rarTsl // = 17

  /// 右侧通行环形路口最终出口方向是向左
  case rarTl // = 18

  /// 右侧通行环形路口最终出口方向是向左前
  case rarTll // = 19

  /// 左侧通行环形路口最终出口方向是直行
  case ralTs // = 20

  /// 左侧通行环形路口最终出口方向是向右前
  case ralTlr // = 21

  /// 左侧通行环形路口最终出口方向是向右
  case ralTr // = 22

  /// 左侧通行环形路口最终出口方向是向右后
  case ralTsr // = 23

  /// 左侧通行环形路口最终出口方向是调头
  case ralTu // = 24

  /// 左侧通行环形路口最终出口方向是向左后
  case ralTsl // = 25

  /// 左侧通行环形路口最终出口方向是向左
  case ralTl // = 26

  /// 左侧通行环形路口最终出口方向是向左前
  case ralTll // = 27

  /// 到达环形路口出口(在31-38，41-48的环岛提示后，会在出环岛的点给出50的tbt标志，用于让设备上停止提示环岛)
  case raExit // = 28
  case UNRECOGNIZED(Int)

  public init() {
    self = .tbtUnknow
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tbtUnknow
    case 1: self = .ts
    case 2: self = .tlr
    case 3: self = .tr
    case 4: self = .tsr
    case 5: self = .tu
    case 6: self = .tsl
    case 7: self = .tl
    case 8: self = .tll
    case 9: self = .tfl
    case 10: self = .tfr
    case 11: self = .roundabout
    case 12: self = .rarTs
    case 13: self = .rarTlr
    case 14: self = .rarTr
    case 15: self = .rarTsr
    case 16: self = .rarTu
    case 17: self = .rarTsl
    case 18: self = .rarTl
    case 19: self = .rarTll
    case 20: self = .ralTs
    case 21: self = .ralTlr
    case 22: self = .ralTr
    case 23: self = .ralTsr
    case 24: self = .ralTu
    case 25: self = .ralTsl
    case 26: self = .ralTl
    case 27: self = .ralTll
    case 28: self = .raExit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tbtUnknow: return 0
    case .ts: return 1
    case .tlr: return 2
    case .tr: return 3
    case .tsr: return 4
    case .tu: return 5
    case .tsl: return 6
    case .tl: return 7
    case .tll: return 8
    case .tfl: return 9
    case .tfr: return 10
    case .roundabout: return 11
    case .rarTs: return 12
    case .rarTlr: return 13
    case .rarTr: return 14
    case .rarTsr: return 15
    case .rarTu: return 16
    case .rarTsl: return 17
    case .rarTl: return 18
    case .rarTll: return 19
    case .ralTs: return 20
    case .ralTlr: return 21
    case .ralTr: return 22
    case .ralTsr: return 23
    case .ralTu: return 24
    case .ralTsl: return 25
    case .ralTl: return 26
    case .ralTll: return 27
    case .raExit: return 28
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CRSTurnByTurnMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CRSTurnByTurnMode] = [
    .tbtUnknow,
    .ts,
    .tlr,
    .tr,
    .tsr,
    .tu,
    .tsl,
    .tl,
    .tll,
    .tfl,
    .tfr,
    .roundabout,
    .rarTs,
    .rarTlr,
    .rarTr,
    .rarTsr,
    .rarTu,
    .rarTsl,
    .rarTl,
    .rarTll,
    .ralTs,
    .ralTlr,
    .ralTr,
    .ralTsr,
    .ralTu,
    .ralTsl,
    .ralTl,
    .ralTll,
    .raExit,
  ]
}

#endif  // swift(>=4.2)

public enum CRSMatchTbtState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 老数据未匹配
  case oldUnmatch // = 0

  /// 老数据已匹配
  case oldMatch // = 1

  /// 手动规划，默认已匹配
  case manual // = 2

  /// 导入未匹配(新数据，导入的时候无网络去匹配)
  case importUnmatch // = 3

  /// 导入已匹配
  case importMatch // = 4

  /// 运动数据转轨迹，未匹配
  case sportDataUnmatch // = 5

  /// 运动数据转轨迹，已匹配
  case sportDataMatch // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .oldUnmatch
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .oldUnmatch
    case 1: self = .oldMatch
    case 2: self = .manual
    case 3: self = .importUnmatch
    case 4: self = .importMatch
    case 5: self = .sportDataUnmatch
    case 6: self = .sportDataMatch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .oldUnmatch: return 0
    case .oldMatch: return 1
    case .manual: return 2
    case .importUnmatch: return 3
    case .importMatch: return 4
    case .sportDataUnmatch: return 5
    case .sportDataMatch: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CRSMatchTbtState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CRSMatchTbtState] = [
    .oldUnmatch,
    .oldMatch,
    .manual,
    .importUnmatch,
    .importMatch,
    .sportDataUnmatch,
    .sportDataMatch,
  ]
}

#endif  // swift(>=4.2)

//// 路径点标记类型
public enum CRSRoutePointMarkType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case markUnknow // = 0

  /// 通过poi或者cp点添加目的地匹配得到的最终点
  case markPoiDes // = 1

  /// 通过手动添加目的地匹配得到的最终点
  case markPositionDes // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .markUnknow
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .markUnknow
    case 1: self = .markPoiDes
    case 2: self = .markPositionDes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .markUnknow: return 0
    case .markPoiDes: return 1
    case .markPositionDes: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CRSRoutePointMarkType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CRSRoutePointMarkType] = [
    .markUnknow,
    .markPoiDes,
    .markPositionDes,
  ]
}

#endif  // swift(>=4.2)

public enum CRSTBTKeyPointType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case keyPointUnknow // = 0

  /// Mapbox的途经点
  case mapbox // = 1

  /// 高德的途经点
  case amap // = 2

  /// google的途经点
  case gmap // = 3

  /// 根据角度计算的转弯点
  case calcTbt // = 100
  case UNRECOGNIZED(Int)

  public init() {
    self = .keyPointUnknow
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .keyPointUnknow
    case 1: self = .mapbox
    case 2: self = .amap
    case 3: self = .gmap
    case 100: self = .calcTbt
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .keyPointUnknow: return 0
    case .mapbox: return 1
    case .amap: return 2
    case .gmap: return 3
    case .calcTbt: return 100
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CRSTBTKeyPointType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CRSTBTKeyPointType] = [
    .keyPointUnknow,
    .mapbox,
    .amap,
    .gmap,
    .calcTbt,
  ]
}

#endif  // swift(>=4.2)

/// 特殊转向类型
public enum CRSExtraTurnType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 正常路口
  case turnTypeNormal // = 0

  /// 环形路口的入口
  case turnTypeRotaryEntr // = 1

  /// 环形路口的路段上
  case turnTypeRotary // = 2

  /// 环形路口的出口
  case turnTypeRotaryExit // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .turnTypeNormal
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .turnTypeNormal
    case 1: self = .turnTypeRotaryEntr
    case 2: self = .turnTypeRotary
    case 3: self = .turnTypeRotaryExit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .turnTypeNormal: return 0
    case .turnTypeRotaryEntr: return 1
    case .turnTypeRotary: return 2
    case .turnTypeRotaryExit: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CRSExtraTurnType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CRSExtraTurnType] = [
    .turnTypeNormal,
    .turnTypeRotaryEntr,
    .turnTypeRotary,
    .turnTypeRotaryExit,
  ]
}

#endif  // swift(>=4.2)

public enum CRSRouteDirectionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 用户使用已有轨迹进行导航
  case trackDirection // = 0

  /// 使用目的地导航临时规划的线路进行导航
  case tempRouteDirection // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .trackDirection
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .trackDirection
    case 1: self = .tempRouteDirection
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .trackDirection: return 0
    case .tempRouteDirection: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CRSRouteDirectionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CRSRouteDirectionType] = [
    .trackDirection,
    .tempRouteDirection,
  ]
}

#endif  // swift(>=4.2)

public enum CRSRouteCorrectionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 服务端成功纠偏，纠偏路线回归到用户原始轨迹终点之外的某个路口
  case correctRoute // = 0

  /// 服务端成功纠偏，纠偏路线经过计算，回归到路线终点
  case correctToDest // = 1

  /// 服务端按照入参强制纠偏到终点
  case forceToDest // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .correctRoute
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .correctRoute
    case 1: self = .correctToDest
    case 2: self = .forceToDest
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .correctRoute: return 0
    case .correctToDest: return 1
    case .forceToDest: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CRSRouteCorrectionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CRSRouteCorrectionType] = [
    .correctRoute,
    .correctToDest,
    .forceToDest,
  ]
}

#endif  // swift(>=4.2)

/// 经纬度
public struct CRSCoordinate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 纬度 *10000000
  public var lat: Int32 = 0

  /// 经度 *10000000
  public var long: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// cp点的额外信息
public struct CRSCPPointAddition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// cp点打开状态
  public var cpOpen: Bool {
    get {return _storage._cpOpen}
    set {_uniqueStorage()._cpOpen = newValue}
  }

  /// 对应路线点index
  public var routeIndex: UInt32 {
    get {return _storage._routeIndex}
    set {_uniqueStorage()._routeIndex = newValue}
  }

  /// 轨迹起点到cp点的距离(mm)
  public var distance: UInt64 {
    get {return _storage._distance}
    set {_uniqueStorage()._distance = newValue}
  }

  /// 轨迹起点到cp点的累计爬升(m)
  public var elevGain: UInt32 {
    get {return _storage._elevGain}
    set {_uniqueStorage()._elevGain = newValue}
  }

  /// 轨迹起点到cp点的累计下降(m)
  public var totalDescent: UInt32 {
    get {return _storage._totalDescent}
    set {_uniqueStorage()._totalDescent = newValue}
  }

  /// 经纬度 在轨迹上的点
  public var coor: CRSCoordinate {
    get {return _storage._coor ?? CRSCoordinate()}
    set {_uniqueStorage()._coor = newValue}
  }
  /// Returns true if `coor` has been explicitly set.
  public var hasCoor: Bool {return _storage._coor != nil}
  /// Clears the value of `coor`. Subsequent reads from it will return its default value.
  public mutating func clearCoor() {_uniqueStorage()._coor = nil}

  /// 给解析库使用，如果为插入点，上传app，需要在route_index的地方插入该坐标
  public var isInsert: Bool {
    get {return _storage._isInsert}
    set {_uniqueStorage()._isInsert = newValue}
  }

  /// 移动端使用，需要插入数据的位置索引
  public var insertIndex: UInt32 {
    get {return _storage._insertIndex}
    set {_uniqueStorage()._insertIndex = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 注释点
public struct CRSAnnotationPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var poi: Com_Yf_Coros_Userdata_PoiInfo {
    get {return _storage._poi ?? Com_Yf_Coros_Userdata_PoiInfo()}
    set {_uniqueStorage()._poi = newValue}
  }
  /// Returns true if `poi` has been explicitly set.
  public var hasPoi: Bool {return _storage._poi != nil}
  /// Clears the value of `poi`. Subsequent reads from it will return its default value.
  public mutating func clearPoi() {_uniqueStorage()._poi = nil}

  /// 点类型
  public var type: CRSAnnotationPointType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// 服务器给的id
  public var serverID: Int64 {
    get {return _storage._serverID}
    set {_uniqueStorage()._serverID = newValue}
  }

  /// 所在城市
  public var city: String {
    get {return _storage._city}
    set {_uniqueStorage()._city = newValue}
  }

  /// 地址信息（固定）
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// cp点的额外信息
  public var cpPoints: [CRSCPPointAddition] {
    get {return _storage._cpPoints}
    set {_uniqueStorage()._cpPoints = newValue}
  }

  /// 过程中的标记，用来上一步下一步使用
  public var available: Bool {
    get {return _storage._available}
    set {_uniqueStorage()._available = newValue}
  }

  /// 编辑点标记
  public var editMark: String {
    get {return _storage._editMark}
    set {_uniqueStorage()._editMark = newValue}
  }

  /// 方位角度 *100
  public var bearing: Int32 {
    get {return _storage._bearing}
    set {_uniqueStorage()._bearing = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 路径点
public struct CRSRoutePoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 经纬度
  public var coor: CRSCoordinate {
    get {return _storage._coor ?? CRSCoordinate()}
    set {_uniqueStorage()._coor = newValue}
  }
  /// Returns true if `coor` has been explicitly set.
  public var hasCoor: Bool {return _storage._coor != nil}
  /// Clears the value of `coor`. Subsequent reads from it will return its default value.
  public mutating func clearCoor() {_uniqueStorage()._coor = nil}

  /// 点的类型（虚线实线点）
  public var style: CRSRoutePointStyle {
    get {return _storage._style}
    set {_uniqueStorage()._style = newValue}
  }

  /// 海拔 m
  public var altitude: Int32 {
    get {return _storage._altitude}
    set {_uniqueStorage()._altitude = newValue}
  }

  /// 过程中的标记，用来上一步下一步使用
  public var available: Bool {
    get {return _storage._available}
    set {_uniqueStorage()._available = newValue}
  }

  /// 轨迹起点到本点的距离(mm)
  public var distance: UInt64 {
    get {return _storage._distance}
    set {_uniqueStorage()._distance = newValue}
  }

  /// 下面是turnByTurn的信息
  public var tbtInfo: CRSTBTRoutePoint {
    get {return _storage._tbtInfo ?? CRSTBTRoutePoint()}
    set {_uniqueStorage()._tbtInfo = newValue}
  }
  /// Returns true if `tbtInfo` has been explicitly set.
  public var hasTbtInfo: Bool {return _storage._tbtInfo != nil}
  /// Clears the value of `tbtInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTbtInfo() {_uniqueStorage()._tbtInfo = nil}

  /// 过滤掉的tbt（不显示）
  public var tbtInfoRemoved: CRSTBTRoutePoint {
    get {return _storage._tbtInfoRemoved ?? CRSTBTRoutePoint()}
    set {_uniqueStorage()._tbtInfoRemoved = newValue}
  }
  /// Returns true if `tbtInfoRemoved` has been explicitly set.
  public var hasTbtInfoRemoved: Bool {return _storage._tbtInfoRemoved != nil}
  /// Clears the value of `tbtInfoRemoved`. Subsequent reads from it will return its default value.
  public mutating func clearTbtInfoRemoved() {_uniqueStorage()._tbtInfoRemoved = nil}

  /// 其他tbt相关（不显示）
  public var tbtInfoReserved: CRSTBTRoutePoint {
    get {return _storage._tbtInfoReserved ?? CRSTBTRoutePoint()}
    set {_uniqueStorage()._tbtInfoReserved = newValue}
  }
  /// Returns true if `tbtInfoReserved` has been explicitly set.
  public var hasTbtInfoReserved: Bool {return _storage._tbtInfoReserved != nil}
  /// Clears the value of `tbtInfoReserved`. Subsequent reads from it will return its default value.
  public mutating func clearTbtInfoReserved() {_uniqueStorage()._tbtInfoReserved = nil}

  /// 路径点标记
  public var mark: UInt32 {
    get {return _storage._mark}
    set {_uniqueStorage()._mark = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 操作
public struct CRSEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 操作类型
  public var type: CRSEventType = .add

  /// 路径点的索引
  public var pathIndexs: [UInt32] = []

  /// 其他点的索引
  public var annoIndexs: [UInt32] = []

  /// 插入数据
  public var insertPoints: [CRSRoutePoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 操作组
public struct CRSAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 操作组合
  public var events: [CRSEvent] {
    get {return _storage._events}
    set {_uniqueStorage()._events = newValue}
  }

  /// 当前选中编辑点 
  public var selectPoint: CRSAnnotationPoint {
    get {return _storage._selectPoint ?? CRSAnnotationPoint()}
    set {_uniqueStorage()._selectPoint = newValue}
  }
  /// Returns true if `selectPoint` has been explicitly set.
  public var hasSelectPoint: Bool {return _storage._selectPoint != nil}
  /// Clears the value of `selectPoint`. Subsequent reads from it will return its default value.
  public mutating func clearSelectPoint() {_uniqueStorage()._selectPoint = nil}

  /// true:执行并跳过 false:只执行不跳过   
  public var proceed: Bool {
    get {return _storage._proceed}
    set {_uniqueStorage()._proceed = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 路径信息
public struct CRSRoutePath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 轨迹的唯一标识
  public var trackID: UInt64 {
    get {return _storage._trackID}
    set {_uniqueStorage()._trackID = newValue}
  }

  /// 路径名称
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// 路径距离 mm
  public var distance: UInt64 {
    get {return _storage._distance}
    set {_uniqueStorage()._distance = newValue}
  }

  /// 路径地址
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// 累积爬升 m
  public var elevGain: UInt32 {
    get {return _storage._elevGain}
    set {_uniqueStorage()._elevGain = newValue}
  }

  /// 累积下降 m
  public var totalDescent: UInt32 {
    get {return _storage._totalDescent}
    set {_uniqueStorage()._totalDescent = newValue}
  }

  /// 路径点集合
  public var pathDatas: [CRSRoutePoint] {
    get {return _storage._pathDatas}
    set {_uniqueStorage()._pathDatas = newValue}
  }

  /// 注释点集合
  public var annoDatas: [CRSAnnotationPoint] {
    get {return _storage._annoDatas}
    set {_uniqueStorage()._annoDatas = newValue}
  }

  /// 是否包含海拔高度
  public var hasAltitude_p: Bool {
    get {return _storage._hasAltitude_p}
    set {_uniqueStorage()._hasAltitude_p = newValue}
  }

  /// 轨迹类型（对应CRSLSportType）
  public var sportType: UInt32 {
    get {return _storage._sportType}
    set {_uniqueStorage()._sportType = newValue}
  }

  public var tbtInfo: CRSTBTRoutePath {
    get {return _storage._tbtInfo ?? CRSTBTRoutePath()}
    set {_uniqueStorage()._tbtInfo = newValue}
  }
  /// Returns true if `tbtInfo` has been explicitly set.
  public var hasTbtInfo: Bool {return _storage._tbtInfo != nil}
  /// Clears the value of `tbtInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTbtInfo() {_uniqueStorage()._tbtInfo = nil}

  /// /// 导入gpx/kml,运动数据转轨迹 时候的匹配信息 
  /// TBTMatchInfo                    match_info                  = 12;
  /// /// 匹配tbt使用的运动类型   
  /// uint32                          match_tbt_sport_type        = 13;
  /// /// MatchTbtState类型
  /// uint32                          match_tbt_state             = 14;
  /// uint32                          match_api_type              = 15;
  /// 路线的版本号，给到固件纠偏使用，同一个track_id修改一次版本号+1
  public var version: UInt32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// 操作步骤
  public var actionMode: CRSActionMode {
    get {return _storage._actionMode}
    set {_uniqueStorage()._actionMode = newValue}
  }

  /// 当前操作索引
  public var actionIndex: UInt32 {
    get {return _storage._actionIndex}
    set {_uniqueStorage()._actionIndex = newValue}
  }

  /// 操作集合
  public var actions: [CRSAction] {
    get {return _storage._actions}
    set {_uniqueStorage()._actions = newValue}
  }

  /// 创建时间戳
  public var createTime: UInt64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  /// 更新时间戳
  public var updateTime: UInt64 {
    get {return _storage._updateTime}
    set {_uniqueStorage()._updateTime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// bsp和app poi数据合并的输入参数和输出结果都是这个结构
public struct CRSPoiMergeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 作为参数：app端根据bps发过来的数据查找到app端poi的list
  //// 作为结果：app和bsp端数据合并之后的结果，app端直接写入到数据库
  public var appPoiArr: [Com_Yf_Coros_Userdata_PoiInfo] = []

  //// 作为参数：协议收到bsp端的poi数组
  //// 作为结果：以app端为准，需要发送给到bsp端的数据，可能为空
  public var bspPoiArr: [Com_Yf_Coros_Userdata_PoiInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 每个点tbt信息
public struct CRSTBTRoutePoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 转向类型 TurnByTurnMode
  public var turnMode: UInt32 = 0

  /// 转向的街道名称
  public var turnStreetName: String = String()

  /// 转向是否可用
  public var turnAvailable: Bool = false

  /// 开始索引
  public var turnStartIndex: UInt32 = 0

  /// 结束索引
  public var turnEndIndex: UInt32 = 0

  /// 是否计算的转角
  public var calcTurn: Bool = false

  /// 本路口中心作为原点，路口可行进方向的方向角，0-360度，数组内每一个值代表一个路口方向，
  /// 0度对应正北，顺时针，例如130度，对应朝接近东南方向（正东南方向是135度）有一条可通行的路线
  public var bearings: [UInt32] = []

  /// 路口信息，路口可通行标志，与bearings指代的路口方向一一对应，如果为false，表示用户不能从这里通行
  /// （一般用户进入路口的方向会标为false）
  public var entries: [Bool] = []

  /// 用户从路口哪一个方向进入路口的，例如1对应bearings[1],130度，说明用户是从路口的东南方向进入路口的
  public var inIndex: UInt32 = 0

  /// 用户从路口哪一个方向出路口的，与inIndex类似
  public var outIndex: UInt32 = 0

  /// 提示复杂转向时的turn_mode类型，如果该tbt或者路口点在环岛中，则对应的是环岛的整体turn_mode(枚举12-27)
  public var extTurnMode: UInt32 = 0

  /// 特殊转向类型 ExtraTurnType
  public var extTurnType: UInt32 = 0

  /// 标记特殊转向时从该点往后直到轨迹转向事件结束这一段的距离（目前环岛上会标识入环岛到出环岛的距离，常规路口时该距离为0），单位毫米
  public var extDistance: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 线路的tbt信息
public struct CRSTBTRoutePath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 导入gpx/kml, 途经点和自己计算的转弯点
  public var matchInfo: CRSTBTMatchInfo {
    get {return _storage._matchInfo ?? CRSTBTMatchInfo()}
    set {_uniqueStorage()._matchInfo = newValue}
  }
  /// Returns true if `matchInfo` has been explicitly set.
  public var hasMatchInfo: Bool {return _storage._matchInfo != nil}
  /// Clears the value of `matchInfo`. Subsequent reads from it will return its default value.
  public mutating func clearMatchInfo() {_uniqueStorage()._matchInfo = nil}

  //// 匹配tbt使用的运动类型   
  public var matchTbtSportType: UInt32 {
    get {return _storage._matchTbtSportType}
    set {_uniqueStorage()._matchTbtSportType = newValue}
  }

  //// MatchTbtState类型
  public var matchTbtState: UInt32 {
    get {return _storage._matchTbtState}
    set {_uniqueStorage()._matchTbtState = newValue}
  }

  public var matchApiType: UInt32 {
    get {return _storage._matchApiType}
    set {_uniqueStorage()._matchApiType = newValue}
  }

  //// 经纬度计算的md5作为tbt的缓存的uuid
  public var matchUuid: String {
    get {return _storage._matchUuid}
    set {_uniqueStorage()._matchUuid = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// turnByTurn 关键点信息
public struct CRSTBTKeyPointInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var index: UInt32 = 0

  /// TBTKeyPointType类型
  public var type: UInt32 = 0

  /// 转向角度，解析库计算的
  public var angle: Double = 0

  /// 转向类型 TurnByTurnMode，自己计算的
  public var turnMode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// turnByTurn 匹配信息
public struct CRSTBTMatchInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyPoints: [CRSTBTKeyPointInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 服务器用户来规划路径匹配途经点用的
public struct CRSTBTMatchWaypointInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var waypoints: [CRSCoordinate] {
    get {return _storage._waypoints}
    set {_uniqueStorage()._waypoints = newValue}
  }

  /// 给到TBTMatchParam的match_info，去匹配tbt
  public var matchInfo: CRSTBTMatchInfo {
    get {return _storage._matchInfo ?? CRSTBTMatchInfo()}
    set {_uniqueStorage()._matchInfo = newValue}
  }
  /// Returns true if `matchInfo` has been explicitly set.
  public var hasMatchInfo: Bool {return _storage._matchInfo != nil}
  /// Clears the value of `matchInfo`. Subsequent reads from it will return its default value.
  public mutating func clearMatchInfo() {_uniqueStorage()._matchInfo = nil}

  //// 经纬度计算的md5作为tbt的缓存的uuid，老的数据看也能没有match_uuid,计算waypoint的时候
  //// 计算一次，给到TBTMatchParam的match_uuid，去匹配tbt
  public var matchUuid: String {
    get {return _storage._matchUuid}
    set {_uniqueStorage()._matchUuid = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// 导入数据匹配tbt的参数
public struct CRSTBTMatchParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var oriPath: CRSRoutePath {
    get {return _storage._oriPath ?? CRSRoutePath()}
    set {_uniqueStorage()._oriPath = newValue}
  }
  /// Returns true if `oriPath` has been explicitly set.
  public var hasOriPath: Bool {return _storage._oriPath != nil}
  /// Clears the value of `oriPath`. Subsequent reads from it will return its default value.
  public mutating func clearOriPath() {_uniqueStorage()._oriPath = nil}

  /// 需要赋值coor、turn_mode
  public var tbtPoints: [CRSRoutePoint] {
    get {return _storage._tbtPoints}
    set {_uniqueStorage()._tbtPoints = newValue}
  }

  /// api规划路径里面包含的tbt点个数
  public var tbtCount: UInt32 {
    get {return _storage._tbtCount}
    set {_uniqueStorage()._tbtCount = newValue}
  }

  /// 调用算法 匹配tbt点 规划轨迹被允许和原始轨迹的最大偏移, 单位m, 默认可设置为50m
  public var matchTrkBias: UInt32 {
    get {return _storage._matchTrkBias}
    set {_uniqueStorage()._matchTrkBias = newValue}
  }

  /// 如果存在，覆盖到返回给到上层的RoutePoint去固化
  public var matchInfo: CRSTBTMatchInfo {
    get {return _storage._matchInfo ?? CRSTBTMatchInfo()}
    set {_uniqueStorage()._matchInfo = newValue}
  }
  /// Returns true if `matchInfo` has been explicitly set.
  public var hasMatchInfo: Bool {return _storage._matchInfo != nil}
  /// Clears the value of `matchInfo`. Subsequent reads from it will return its default value.
  public mutating func clearMatchInfo() {_uniqueStorage()._matchInfo = nil}

  /// 请求的api类型（TBTKeyPointType）
  public var apiType: UInt32 {
    get {return _storage._apiType}
    set {_uniqueStorage()._apiType = newValue}
  }

  /// 如果存在，匹配的时候，会写入到RoutePoint去固化
  public var matchUuid: String {
    get {return _storage._matchUuid}
    set {_uniqueStorage()._matchUuid = newValue}
  }

  /// 规划轨迹被允许和原始轨迹的角度偏差, 单位deg, 默认可设置为50
  public var matchHeadingBias: UInt32 {
    get {return _storage._matchHeadingBias}
    set {_uniqueStorage()._matchHeadingBias = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 纠偏路径信息，由服务端接口生成返回给app
/// 如果用户是在一次偏离过程中再次偏离，服务端返回的是从二次偏离的起点到原路径上回归点的路径纠偏数据
public struct CRSRoutePathCorrection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 纠偏参数
  public var param: CRSRoutePathCorrectionParam {
    get {return _storage._param ?? CRSRoutePathCorrectionParam()}
    set {_uniqueStorage()._param = newValue}
  }
  /// Returns true if `param` has been explicitly set.
  public var hasParam: Bool {return _storage._param != nil}
  /// Clears the value of `param`. Subsequent reads from it will return its default value.
  public mutating func clearParam() {_uniqueStorage()._param = nil}

  /// 纠偏id，服务端为每一次成功的纠偏请求生成一个用户唯一的id，0为无效值
  public var correctionID: UInt64 {
    get {return _storage._correctionID}
    set {_uniqueStorage()._correctionID = newValue}
  }

  /// 服务端生成纠偏路径的类型
  public var serverCorrectionType: CRSRouteCorrectionType {
    get {return _storage._serverCorrectionType}
    set {_uniqueStorage()._serverCorrectionType = newValue}
  }

  /// 纠偏回归的原路径终点坐标index，-1为无效值（当服务端直接基于入参用户目的地强制生成导航路线时）
  /// 注意，该index是服务端保存的轨迹里的index，调用解析库转换为bsp数据格式时会转换成bsp轨迹里的index
  public var oriEndIndex: Int32 {
    get {return _storage._oriEndIndex}
    set {_uniqueStorage()._oriEndIndex = newValue}
  }

  /// 本段纠偏路径距离 mm
  public var distance: UInt64 {
    get {return _storage._distance}
    set {_uniqueStorage()._distance = newValue}
  }

  /// 从第1个偏离特征坐标点到回归原路径的坐标集合，第一个点对应入参中spec_coords第一个点，最后一个点是ori_end_index对应的原轨迹上的点，
  /// 其中也会包含tbt信息
  public var correctedPathDatas: [CRSRoutePoint] {
    get {return _storage._correctedPathDatas}
    set {_uniqueStorage()._correctedPathDatas = newValue}
  }

  /// 原始轨迹/目的地导航的点数据(对应RoutePath的pbbuffer)
  public var oriPathDatas: Data {
    get {return _storage._oriPathDatas}
    set {_uniqueStorage()._oriPathDatas = newValue}
  }

  /// 错误码 0-正常，1-请求地图供应商没有获取到纠偏路径，2-其他错误
  public var errCode: UInt32 {
    get {return _storage._errCode}
    set {_uniqueStorage()._errCode = newValue}
  }

  /// 时间戳
  public var timestamp: UInt64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 纠偏请求服务端接口参数
public struct CRSRoutePathCorrectionParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 轨迹id/临时路线id(app直接发送目的地导航到手表时)
  public var trackID: UInt64 {
    get {return _storage._trackID}
    set {_uniqueStorage()._trackID = newValue}
  }

  /// 轨迹版本（bsp上的轨迹版本可能与服务端保存的用户该轨迹的最新版本不同）
  public var trackVersion: UInt32 {
    get {return _storage._trackVersion}
    set {_uniqueStorage()._trackVersion = newValue}
  }

  /// 轨迹导航类型，0-已有轨迹导航，1-目的地导航
  public var routeDirectionType: CRSRouteDirectionType {
    get {return _storage._routeDirectionType}
    set {_uniqueStorage()._routeDirectionType = newValue}
  }

  /// 导航时间戳，服务端会基于用户id+轨迹id+导航类型+时间戳+运动类型来作为唯一标志对应用户的一次导航过程
  public var directionStartTime: UInt64 {
    get {return _storage._directionStartTime}
    set {_uniqueStorage()._directionStartTime = newValue}
  }

  /// 运动类型
  public var sportType: UInt32 {
    get {return _storage._sportType}
    set {_uniqueStorage()._sportType = newValue}
  }

  /// 纠偏类型
  /// 0-基于服务端判断逻辑，当传入0时，响应里server_correction_type可能为0或1或2（如果匹配路线异常）
  /// 2-强制纠偏到路线终点，当传入2时，响应里server_correction_type一定为2
  public var correctionType: CRSRouteCorrectionType {
    get {return _storage._correctionType}
    set {_uniqueStorage()._correctionType = newValue}
  }

  /// 如果是已在纠偏路径上的情况下再次纠偏，则bsp要把当前用户正在使用的纠偏数据的local_id传入，否则传入0无效值（或不写入数据，会解析为0）
  public var parentCorrectionID: UInt64 {
    get {return _storage._parentCorrectionID}
    set {_uniqueStorage()._parentCorrectionID = newValue}
  }

  /// 偏离出的原路径或纠偏路径的起点坐标index，如果用户是从路线信息中2个坐标点中间位置偏离，则本index设置为这2个点中用户已经通过(或者映射通过)的点，
  /// 注意，该index是服务端保存的轨迹里的index，调用解析库将bsp传入的参数转换为本结构的时候会进行转换计算
  public var oriStartIndex: UInt32 {
    get {return _storage._oriStartIndex}
    set {_uniqueStorage()._oriStartIndex = newValue}
  }

  /// BSP基于用户的偏离情况，按行进顺序，提取出至少1个特征坐标点（至少包含用户当前所在点），用于计算纠偏
  public var specCoords: [CRSCoordinate] {
    get {return _storage._specCoords}
    set {_uniqueStorage()._specCoords = newValue}
  }

  /// 用户的目的地，当轨迹在服务端无法匹配时（例如bsp使用的路线版本在服务端无法匹配，或传入的终点与对应路线的终点不一致时），服务端直接基于该终点进行规划
  public var destPoint: CRSCoordinate {
    get {return _storage._destPoint ?? CRSCoordinate()}
    set {_uniqueStorage()._destPoint = newValue}
  }
  /// Returns true if `destPoint` has been explicitly set.
  public var hasDestPoint: Bool {return _storage._destPoint != nil}
  /// Clears the value of `destPoint`. Subsequent reads from it will return its default value.
  public mutating func clearDestPoint() {_uniqueStorage()._destPoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 服务器下发的RoutePathCorrection数据转换为发送给到设备的数据
public struct CRSRouteCorrectionSendBspData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 通过命令通道发送0xAA发送给到设备的纠偏信息的错误代码
  /// correction_code=1(PROTOCOL_SUCCESS)时，route_correction_info才需要一块发送给到设备，否则只发送correction_code
  public var correctionCode: UInt32 = 0

  /// 通过命令通道发送0xAA发送给到设备的纠偏信息
  public var routeCorrectionInfo: Data = SwiftProtobuf.Internal.emptyData

  /// 通过数据通道发送file_index为0x42发送给到设备的纠偏的数据
  public var routeCorrectionData: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CRSTrackClimbLevelItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 开始距离 mm 距离开始点的距离
  public var startDistance: UInt32 = 0

  /// 结束距离 mm 距离开始点的距离
  public var endDistance: UInt32 = 0

  /// 对应高度点开始的index
  public var startIndex: UInt32 = 0

  /// 对应高度点结束的index
  public var endIndex: UInt32 = 0

  /// 坡度等级 0:未满足爬坡段的所有坡度  满足爬坡段(1-5)1:<3%坡度段 2:<6%坡度段 3:<9%坡度段 4:<12%坡度段 5:>=12%坡度段
  public var slopeLevel: UInt32 = 0

  /// 平均坡度 % 
  public var avgSlope: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 一个坡段信息
public struct CRSTrackClimbProItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 开始距离 mm 距离开始点的距离
  public var startDistance: UInt32 = 0

  /// 结束距离 mm 距离开始点的距离
  public var endDistance: UInt32 = 0

  /// 对应高度点开始的index
  public var startIndex: UInt32 = 0

  /// 对应高度点结束的index
  public var endIndex: UInt32 = 0

  /// 平均坡度 %
  public var avgSlope: Int32 = 0

  /// 坡段的累加爬升 m
  public var elevGain: Int32 = 0

  /// 在TrackClimbLevelInfo的开始下标
  public var startLevelIndex: UInt32 = 0

  /// 在TrackClimbLevelInfo的结束下标
  public var endLevelIndex: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 爬坡信息
public struct CRSTrackClimbInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 坡度等级，画颜色使用  
  public var slopeLevelArr: [CRSTrackClimbLevelItem] = []

  /// 爬坡信息
  public var climbProArr: [CRSTrackClimbProItem] = []

  /// 整个轨迹的平均坡度 %
  public var avgSlope: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.yf.coros.userdata"

extension CRSPoiType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POI_STAR"),
    1: .same(proto: "POI_SUPPLY"),
    2: .same(proto: "POI_END"),
    3: .same(proto: "POI_CP"),
    4: .same(proto: "POI_PARK"),
    5: .same(proto: "POI_HILL"),
    6: .same(proto: "POI_PHOTO"),
    7: .same(proto: "POI_TENT"),
    8: .same(proto: "POI_FOREST"),
    9: .same(proto: "POI_HAZARD"),
    10: .same(proto: "POI_HOME"),
    11: .same(proto: "POI_SNOW"),
    12: .same(proto: "POI_FISH"),
    13: .same(proto: "POI_LIKE"),
    14: .same(proto: "POI_HIGH"),
    15: .same(proto: "POI_ROAD"),
    16: .same(proto: "POI_START"),
    17: .same(proto: "POI_RIVER"),
    18: .same(proto: "POI_FOOTPRINT"),
    19: .same(proto: "POI_PIN"),
    20: .same(proto: "POI_BRANCH"),
    21: .same(proto: "POI_REED"),
    22: .same(proto: "POI_DUCKWEED"),
    23: .same(proto: "POI_REEF"),
    24: .same(proto: "POI_FAULT"),
    25: .same(proto: "POI_LANDSLIDE"),
    26: .same(proto: "POI_CAPE"),
    27: .same(proto: "POI_DOCK"),
    28: .same(proto: "POI_PIER"),
    29: .same(proto: "POI_VOICE"),
    255: .same(proto: "POI_WAYPOINT"),
  ]
}

extension CRSEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "CLEAN"),
    2: .same(proto: "CLEANED"),
    3: .same(proto: "DELETE"),
    4: .same(proto: "INSERT"),
    5: .same(proto: "INVERT"),
    6: .same(proto: "ADD_START"),
    7: .same(proto: "DEL_START"),
    8: .same(proto: "ADD_END"),
    9: .same(proto: "DEL_END"),
    10: .same(proto: "ADD_POI"),
    11: .same(proto: "DEL_POI"),
    12: .same(proto: "ADD_POSITION"),
    13: .same(proto: "DEL_POSITION"),
    14: .same(proto: "SELECT"),
  ]
}

extension CRSAnnotationPointType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "START"),
    1: .same(proto: "END"),
    2: .same(proto: "POI"),
    3: .same(proto: "POSITION"),
    4: .same(proto: "EDIT"),
    5: .same(proto: "CORNER"),
  ]
}

extension CRSRoutePointStyle: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOLID"),
    1: .same(proto: "DOTTED"),
    2: .same(proto: "EDITING"),
    3: .same(proto: "DELETING"),
  ]
}

extension CRSActionMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "MATCH_WALK"),
    2: .same(proto: "MATCH_CYCLE"),
    3: .same(proto: "POINT_FREE"),
    4: .same(proto: "DRAW_FREE"),
    5: .same(proto: "MARK_POSITION"),
    6: .same(proto: "CLEAN_PATH"),
    7: .same(proto: "CLEANED_PATH"),
  ]
}

extension CRSTurnByTurnMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TBT_UNKNOW"),
    1: .same(proto: "TS"),
    2: .same(proto: "TLR"),
    3: .same(proto: "TR"),
    4: .same(proto: "TSR"),
    5: .same(proto: "TU"),
    6: .same(proto: "TSL"),
    7: .same(proto: "TL"),
    8: .same(proto: "TLL"),
    9: .same(proto: "TFL"),
    10: .same(proto: "TFR"),
    11: .same(proto: "ROUNDABOUT"),
    12: .same(proto: "RAR_TS"),
    13: .same(proto: "RAR_TLR"),
    14: .same(proto: "RAR_TR"),
    15: .same(proto: "RAR_TSR"),
    16: .same(proto: "RAR_TU"),
    17: .same(proto: "RAR_TSL"),
    18: .same(proto: "RAR_TL"),
    19: .same(proto: "RAR_TLL"),
    20: .same(proto: "RAL_TS"),
    21: .same(proto: "RAL_TLR"),
    22: .same(proto: "RAL_TR"),
    23: .same(proto: "RAL_TSR"),
    24: .same(proto: "RAL_TU"),
    25: .same(proto: "RAL_TSL"),
    26: .same(proto: "RAL_TL"),
    27: .same(proto: "RAL_TLL"),
    28: .same(proto: "RA_EXIT"),
  ]
}

extension CRSMatchTbtState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OLD_UNMATCH"),
    1: .same(proto: "OLD_MATCH"),
    2: .same(proto: "MANUAL"),
    3: .same(proto: "IMPORT_UNMATCH"),
    4: .same(proto: "IMPORT_MATCH"),
    5: .same(proto: "SPORT_DATA_UNMATCH"),
    6: .same(proto: "SPORT_DATA_MATCH"),
  ]
}

extension CRSRoutePointMarkType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MARK_UNKNOW"),
    1: .same(proto: "MARK_POI_DES"),
    2: .same(proto: "MARK_POSITION_DES"),
  ]
}

extension CRSTBTKeyPointType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_POINT_UNKNOW"),
    1: .same(proto: "MAPBOX"),
    2: .same(proto: "AMAP"),
    3: .same(proto: "GMAP"),
    100: .same(proto: "CALC_TBT"),
  ]
}

extension CRSExtraTurnType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TURN_TYPE_NORMAL"),
    1: .same(proto: "TURN_TYPE_ROTARY_ENTR"),
    2: .same(proto: "TURN_TYPE_ROTARY"),
    3: .same(proto: "TURN_TYPE_ROTARY_EXIT"),
  ]
}

extension CRSRouteDirectionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRACK_DIRECTION"),
    1: .same(proto: "TEMP_ROUTE_DIRECTION"),
  ]
}

extension CRSRouteCorrectionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CORRECT_ROUTE"),
    1: .same(proto: "CORRECT_TO_DEST"),
    2: .same(proto: "FORCE_TO_DEST"),
  ]
}

extension CRSCoordinate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Coordinate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "lat"),
    3: .same(proto: "long"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularSInt32Field(value: &self.lat)
      case 3: try decoder.decodeSingularSInt32Field(value: &self.long)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat != 0 {
      try visitor.visitSingularSInt32Field(value: self.lat, fieldNumber: 2)
    }
    if self.long != 0 {
      try visitor.visitSingularSInt32Field(value: self.long, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSCoordinate, rhs: CRSCoordinate) -> Bool {
    if lhs.lat != rhs.lat {return false}
    if lhs.long != rhs.long {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSCPPointAddition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CPPointAddition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cp_open"),
    2: .standard(proto: "route_index"),
    3: .same(proto: "distance"),
    4: .standard(proto: "elev_gain"),
    5: .standard(proto: "total_descent"),
    6: .same(proto: "coor"),
    7: .standard(proto: "is_insert"),
    8: .standard(proto: "insert_index"),
  ]

  fileprivate class _StorageClass {
    var _cpOpen: Bool = false
    var _routeIndex: UInt32 = 0
    var _distance: UInt64 = 0
    var _elevGain: UInt32 = 0
    var _totalDescent: UInt32 = 0
    var _coor: CRSCoordinate? = nil
    var _isInsert: Bool = false
    var _insertIndex: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cpOpen = source._cpOpen
      _routeIndex = source._routeIndex
      _distance = source._distance
      _elevGain = source._elevGain
      _totalDescent = source._totalDescent
      _coor = source._coor
      _isInsert = source._isInsert
      _insertIndex = source._insertIndex
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._cpOpen)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._routeIndex)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._distance)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._elevGain)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._totalDescent)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._coor)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._isInsert)
        case 8: try decoder.decodeSingularUInt32Field(value: &_storage._insertIndex)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._cpOpen != false {
        try visitor.visitSingularBoolField(value: _storage._cpOpen, fieldNumber: 1)
      }
      if _storage._routeIndex != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._routeIndex, fieldNumber: 2)
      }
      if _storage._distance != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._distance, fieldNumber: 3)
      }
      if _storage._elevGain != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._elevGain, fieldNumber: 4)
      }
      if _storage._totalDescent != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._totalDescent, fieldNumber: 5)
      }
      if let v = _storage._coor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._isInsert != false {
        try visitor.visitSingularBoolField(value: _storage._isInsert, fieldNumber: 7)
      }
      if _storage._insertIndex != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._insertIndex, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSCPPointAddition, rhs: CRSCPPointAddition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cpOpen != rhs_storage._cpOpen {return false}
        if _storage._routeIndex != rhs_storage._routeIndex {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._elevGain != rhs_storage._elevGain {return false}
        if _storage._totalDescent != rhs_storage._totalDescent {return false}
        if _storage._coor != rhs_storage._coor {return false}
        if _storage._isInsert != rhs_storage._isInsert {return false}
        if _storage._insertIndex != rhs_storage._insertIndex {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSAnnotationPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotationPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "poi"),
    2: .same(proto: "type"),
    3: .standard(proto: "server_id"),
    4: .same(proto: "city"),
    5: .same(proto: "address"),
    6: .standard(proto: "cp_points"),
    7: .same(proto: "available"),
    8: .standard(proto: "edit_mark"),
    9: .same(proto: "bearing"),
  ]

  fileprivate class _StorageClass {
    var _poi: Com_Yf_Coros_Userdata_PoiInfo? = nil
    var _type: CRSAnnotationPointType = .start
    var _serverID: Int64 = 0
    var _city: String = String()
    var _address: String = String()
    var _cpPoints: [CRSCPPointAddition] = []
    var _available: Bool = false
    var _editMark: String = String()
    var _bearing: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _poi = source._poi
      _type = source._type
      _serverID = source._serverID
      _city = source._city
      _address = source._address
      _cpPoints = source._cpPoints
      _available = source._available
      _editMark = source._editMark
      _bearing = source._bearing
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._poi)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._serverID)
        case 4: try decoder.decodeSingularStringField(value: &_storage._city)
        case 5: try decoder.decodeSingularStringField(value: &_storage._address)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._cpPoints)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._available)
        case 8: try decoder.decodeSingularStringField(value: &_storage._editMark)
        case 9: try decoder.decodeSingularSInt32Field(value: &_storage._bearing)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._poi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._type != .start {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if _storage._serverID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._serverID, fieldNumber: 3)
      }
      if !_storage._city.isEmpty {
        try visitor.visitSingularStringField(value: _storage._city, fieldNumber: 4)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 5)
      }
      if !_storage._cpPoints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cpPoints, fieldNumber: 6)
      }
      if _storage._available != false {
        try visitor.visitSingularBoolField(value: _storage._available, fieldNumber: 7)
      }
      if !_storage._editMark.isEmpty {
        try visitor.visitSingularStringField(value: _storage._editMark, fieldNumber: 8)
      }
      if _storage._bearing != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._bearing, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSAnnotationPoint, rhs: CRSAnnotationPoint) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._poi != rhs_storage._poi {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._serverID != rhs_storage._serverID {return false}
        if _storage._city != rhs_storage._city {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._cpPoints != rhs_storage._cpPoints {return false}
        if _storage._available != rhs_storage._available {return false}
        if _storage._editMark != rhs_storage._editMark {return false}
        if _storage._bearing != rhs_storage._bearing {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSRoutePoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RoutePoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coor"),
    2: .same(proto: "style"),
    3: .same(proto: "altitude"),
    4: .same(proto: "available"),
    5: .same(proto: "distance"),
    6: .standard(proto: "tbt_info"),
    7: .standard(proto: "tbt_info_removed"),
    8: .standard(proto: "tbt_info_reserved"),
    15: .same(proto: "mark"),
  ]

  fileprivate class _StorageClass {
    var _coor: CRSCoordinate? = nil
    var _style: CRSRoutePointStyle = .solid
    var _altitude: Int32 = 0
    var _available: Bool = false
    var _distance: UInt64 = 0
    var _tbtInfo: CRSTBTRoutePoint? = nil
    var _tbtInfoRemoved: CRSTBTRoutePoint? = nil
    var _tbtInfoReserved: CRSTBTRoutePoint? = nil
    var _mark: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _coor = source._coor
      _style = source._style
      _altitude = source._altitude
      _available = source._available
      _distance = source._distance
      _tbtInfo = source._tbtInfo
      _tbtInfoRemoved = source._tbtInfoRemoved
      _tbtInfoReserved = source._tbtInfoReserved
      _mark = source._mark
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._coor)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._style)
        case 3: try decoder.decodeSingularSInt32Field(value: &_storage._altitude)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._available)
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._distance)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._tbtInfo)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._tbtInfoRemoved)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._tbtInfoReserved)
        case 15: try decoder.decodeSingularUInt32Field(value: &_storage._mark)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._coor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._style != .solid {
        try visitor.visitSingularEnumField(value: _storage._style, fieldNumber: 2)
      }
      if _storage._altitude != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._altitude, fieldNumber: 3)
      }
      if _storage._available != false {
        try visitor.visitSingularBoolField(value: _storage._available, fieldNumber: 4)
      }
      if _storage._distance != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._distance, fieldNumber: 5)
      }
      if let v = _storage._tbtInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._tbtInfoRemoved {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._tbtInfoReserved {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if _storage._mark != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._mark, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSRoutePoint, rhs: CRSRoutePoint) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._coor != rhs_storage._coor {return false}
        if _storage._style != rhs_storage._style {return false}
        if _storage._altitude != rhs_storage._altitude {return false}
        if _storage._available != rhs_storage._available {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._tbtInfo != rhs_storage._tbtInfo {return false}
        if _storage._tbtInfoRemoved != rhs_storage._tbtInfoRemoved {return false}
        if _storage._tbtInfoReserved != rhs_storage._tbtInfoReserved {return false}
        if _storage._mark != rhs_storage._mark {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "path_indexs"),
    3: .standard(proto: "anno_indexs"),
    4: .standard(proto: "insert_points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeRepeatedUInt32Field(value: &self.pathIndexs)
      case 3: try decoder.decodeRepeatedUInt32Field(value: &self.annoIndexs)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.insertPoints)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .add {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.pathIndexs.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.pathIndexs, fieldNumber: 2)
    }
    if !self.annoIndexs.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.annoIndexs, fieldNumber: 3)
    }
    if !self.insertPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insertPoints, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSEvent, rhs: CRSEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.pathIndexs != rhs.pathIndexs {return false}
    if lhs.annoIndexs != rhs.annoIndexs {return false}
    if lhs.insertPoints != rhs.insertPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
    2: .standard(proto: "select_point"),
    3: .same(proto: "proceed"),
  ]

  fileprivate class _StorageClass {
    var _events: [CRSEvent] = []
    var _selectPoint: CRSAnnotationPoint? = nil
    var _proceed: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _events = source._events
      _selectPoint = source._selectPoint
      _proceed = source._proceed
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._events)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._selectPoint)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._proceed)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._events.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._events, fieldNumber: 1)
      }
      if let v = _storage._selectPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._proceed != false {
        try visitor.visitSingularBoolField(value: _storage._proceed, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSAction, rhs: CRSAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._events != rhs_storage._events {return false}
        if _storage._selectPoint != rhs_storage._selectPoint {return false}
        if _storage._proceed != rhs_storage._proceed {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSRoutePath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RoutePath"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "track_id"),
    2: .same(proto: "name"),
    3: .same(proto: "distance"),
    4: .same(proto: "address"),
    5: .standard(proto: "elev_gain"),
    6: .standard(proto: "total_descent"),
    7: .standard(proto: "path_datas"),
    8: .standard(proto: "anno_datas"),
    10: .standard(proto: "has_altitude"),
    11: .standard(proto: "sport_type"),
    12: .standard(proto: "tbt_info"),
    13: .same(proto: "version"),
    21: .standard(proto: "action_mode"),
    22: .standard(proto: "action_index"),
    23: .same(proto: "actions"),
    24: .standard(proto: "create_time"),
    25: .standard(proto: "update_time"),
  ]

  fileprivate class _StorageClass {
    var _trackID: UInt64 = 0
    var _name: String = String()
    var _distance: UInt64 = 0
    var _address: String = String()
    var _elevGain: UInt32 = 0
    var _totalDescent: UInt32 = 0
    var _pathDatas: [CRSRoutePoint] = []
    var _annoDatas: [CRSAnnotationPoint] = []
    var _hasAltitude_p: Bool = false
    var _sportType: UInt32 = 0
    var _tbtInfo: CRSTBTRoutePath? = nil
    var _version: UInt32 = 0
    var _actionMode: CRSActionMode = .normal
    var _actionIndex: UInt32 = 0
    var _actions: [CRSAction] = []
    var _createTime: UInt64 = 0
    var _updateTime: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _trackID = source._trackID
      _name = source._name
      _distance = source._distance
      _address = source._address
      _elevGain = source._elevGain
      _totalDescent = source._totalDescent
      _pathDatas = source._pathDatas
      _annoDatas = source._annoDatas
      _hasAltitude_p = source._hasAltitude_p
      _sportType = source._sportType
      _tbtInfo = source._tbtInfo
      _version = source._version
      _actionMode = source._actionMode
      _actionIndex = source._actionIndex
      _actions = source._actions
      _createTime = source._createTime
      _updateTime = source._updateTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._trackID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._distance)
        case 4: try decoder.decodeSingularStringField(value: &_storage._address)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._elevGain)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._totalDescent)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._pathDatas)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._annoDatas)
        case 10: try decoder.decodeSingularBoolField(value: &_storage._hasAltitude_p)
        case 11: try decoder.decodeSingularUInt32Field(value: &_storage._sportType)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._tbtInfo)
        case 13: try decoder.decodeSingularUInt32Field(value: &_storage._version)
        case 21: try decoder.decodeSingularEnumField(value: &_storage._actionMode)
        case 22: try decoder.decodeSingularUInt32Field(value: &_storage._actionIndex)
        case 23: try decoder.decodeRepeatedMessageField(value: &_storage._actions)
        case 24: try decoder.decodeSingularUInt64Field(value: &_storage._createTime)
        case 25: try decoder.decodeSingularUInt64Field(value: &_storage._updateTime)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._trackID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._trackID, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if _storage._distance != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._distance, fieldNumber: 3)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 4)
      }
      if _storage._elevGain != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._elevGain, fieldNumber: 5)
      }
      if _storage._totalDescent != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._totalDescent, fieldNumber: 6)
      }
      if !_storage._pathDatas.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pathDatas, fieldNumber: 7)
      }
      if !_storage._annoDatas.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._annoDatas, fieldNumber: 8)
      }
      if _storage._hasAltitude_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasAltitude_p, fieldNumber: 10)
      }
      if _storage._sportType != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sportType, fieldNumber: 11)
      }
      if let v = _storage._tbtInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if _storage._version != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._version, fieldNumber: 13)
      }
      if _storage._actionMode != .normal {
        try visitor.visitSingularEnumField(value: _storage._actionMode, fieldNumber: 21)
      }
      if _storage._actionIndex != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._actionIndex, fieldNumber: 22)
      }
      if !_storage._actions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actions, fieldNumber: 23)
      }
      if _storage._createTime != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._createTime, fieldNumber: 24)
      }
      if _storage._updateTime != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._updateTime, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSRoutePath, rhs: CRSRoutePath) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._trackID != rhs_storage._trackID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._elevGain != rhs_storage._elevGain {return false}
        if _storage._totalDescent != rhs_storage._totalDescent {return false}
        if _storage._pathDatas != rhs_storage._pathDatas {return false}
        if _storage._annoDatas != rhs_storage._annoDatas {return false}
        if _storage._hasAltitude_p != rhs_storage._hasAltitude_p {return false}
        if _storage._sportType != rhs_storage._sportType {return false}
        if _storage._tbtInfo != rhs_storage._tbtInfo {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._actionMode != rhs_storage._actionMode {return false}
        if _storage._actionIndex != rhs_storage._actionIndex {return false}
        if _storage._actions != rhs_storage._actions {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSPoiMergeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PoiMergeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_poi_arr"),
    2: .standard(proto: "bsp_poi_arr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.appPoiArr)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.bspPoiArr)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appPoiArr.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.appPoiArr, fieldNumber: 1)
    }
    if !self.bspPoiArr.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bspPoiArr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSPoiMergeInfo, rhs: CRSPoiMergeInfo) -> Bool {
    if lhs.appPoiArr != rhs.appPoiArr {return false}
    if lhs.bspPoiArr != rhs.bspPoiArr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSTBTRoutePoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TBTRoutePoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "turn_mode"),
    2: .standard(proto: "turn_street_name"),
    3: .standard(proto: "turn_available"),
    4: .standard(proto: "turn_start_index"),
    5: .standard(proto: "turn_end_index"),
    6: .standard(proto: "calc_turn"),
    7: .same(proto: "bearings"),
    8: .same(proto: "entries"),
    9: .standard(proto: "in_index"),
    10: .standard(proto: "out_index"),
    11: .standard(proto: "ext_turn_mode"),
    12: .standard(proto: "ext_turn_type"),
    13: .standard(proto: "ext_distance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.turnMode)
      case 2: try decoder.decodeSingularStringField(value: &self.turnStreetName)
      case 3: try decoder.decodeSingularBoolField(value: &self.turnAvailable)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.turnStartIndex)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.turnEndIndex)
      case 6: try decoder.decodeSingularBoolField(value: &self.calcTurn)
      case 7: try decoder.decodeRepeatedUInt32Field(value: &self.bearings)
      case 8: try decoder.decodeRepeatedBoolField(value: &self.entries)
      case 9: try decoder.decodeSingularUInt32Field(value: &self.inIndex)
      case 10: try decoder.decodeSingularUInt32Field(value: &self.outIndex)
      case 11: try decoder.decodeSingularUInt32Field(value: &self.extTurnMode)
      case 12: try decoder.decodeSingularUInt32Field(value: &self.extTurnType)
      case 13: try decoder.decodeSingularUInt64Field(value: &self.extDistance)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.turnMode != 0 {
      try visitor.visitSingularUInt32Field(value: self.turnMode, fieldNumber: 1)
    }
    if !self.turnStreetName.isEmpty {
      try visitor.visitSingularStringField(value: self.turnStreetName, fieldNumber: 2)
    }
    if self.turnAvailable != false {
      try visitor.visitSingularBoolField(value: self.turnAvailable, fieldNumber: 3)
    }
    if self.turnStartIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.turnStartIndex, fieldNumber: 4)
    }
    if self.turnEndIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.turnEndIndex, fieldNumber: 5)
    }
    if self.calcTurn != false {
      try visitor.visitSingularBoolField(value: self.calcTurn, fieldNumber: 6)
    }
    if !self.bearings.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.bearings, fieldNumber: 7)
    }
    if !self.entries.isEmpty {
      try visitor.visitPackedBoolField(value: self.entries, fieldNumber: 8)
    }
    if self.inIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.inIndex, fieldNumber: 9)
    }
    if self.outIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.outIndex, fieldNumber: 10)
    }
    if self.extTurnMode != 0 {
      try visitor.visitSingularUInt32Field(value: self.extTurnMode, fieldNumber: 11)
    }
    if self.extTurnType != 0 {
      try visitor.visitSingularUInt32Field(value: self.extTurnType, fieldNumber: 12)
    }
    if self.extDistance != 0 {
      try visitor.visitSingularUInt64Field(value: self.extDistance, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSTBTRoutePoint, rhs: CRSTBTRoutePoint) -> Bool {
    if lhs.turnMode != rhs.turnMode {return false}
    if lhs.turnStreetName != rhs.turnStreetName {return false}
    if lhs.turnAvailable != rhs.turnAvailable {return false}
    if lhs.turnStartIndex != rhs.turnStartIndex {return false}
    if lhs.turnEndIndex != rhs.turnEndIndex {return false}
    if lhs.calcTurn != rhs.calcTurn {return false}
    if lhs.bearings != rhs.bearings {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.inIndex != rhs.inIndex {return false}
    if lhs.outIndex != rhs.outIndex {return false}
    if lhs.extTurnMode != rhs.extTurnMode {return false}
    if lhs.extTurnType != rhs.extTurnType {return false}
    if lhs.extDistance != rhs.extDistance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSTBTRoutePath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TBTRoutePath"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_info"),
    2: .standard(proto: "match_tbt_sport_type"),
    3: .standard(proto: "match_tbt_state"),
    4: .standard(proto: "match_api_type"),
    5: .standard(proto: "match_uuid"),
  ]

  fileprivate class _StorageClass {
    var _matchInfo: CRSTBTMatchInfo? = nil
    var _matchTbtSportType: UInt32 = 0
    var _matchTbtState: UInt32 = 0
    var _matchApiType: UInt32 = 0
    var _matchUuid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _matchInfo = source._matchInfo
      _matchTbtSportType = source._matchTbtSportType
      _matchTbtState = source._matchTbtState
      _matchApiType = source._matchApiType
      _matchUuid = source._matchUuid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._matchInfo)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._matchTbtSportType)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._matchTbtState)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._matchApiType)
        case 5: try decoder.decodeSingularStringField(value: &_storage._matchUuid)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._matchInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._matchTbtSportType != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._matchTbtSportType, fieldNumber: 2)
      }
      if _storage._matchTbtState != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._matchTbtState, fieldNumber: 3)
      }
      if _storage._matchApiType != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._matchApiType, fieldNumber: 4)
      }
      if !_storage._matchUuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._matchUuid, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSTBTRoutePath, rhs: CRSTBTRoutePath) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._matchInfo != rhs_storage._matchInfo {return false}
        if _storage._matchTbtSportType != rhs_storage._matchTbtSportType {return false}
        if _storage._matchTbtState != rhs_storage._matchTbtState {return false}
        if _storage._matchApiType != rhs_storage._matchApiType {return false}
        if _storage._matchUuid != rhs_storage._matchUuid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSTBTKeyPointInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TBTKeyPointInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "type"),
    3: .same(proto: "angle"),
    4: .standard(proto: "turn_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.index)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.type)
      case 3: try decoder.decodeSingularDoubleField(value: &self.angle)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.turnMode)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularUInt32Field(value: self.type, fieldNumber: 2)
    }
    if self.angle != 0 {
      try visitor.visitSingularDoubleField(value: self.angle, fieldNumber: 3)
    }
    if self.turnMode != 0 {
      try visitor.visitSingularUInt32Field(value: self.turnMode, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSTBTKeyPointInfo, rhs: CRSTBTKeyPointInfo) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.type != rhs.type {return false}
    if lhs.angle != rhs.angle {return false}
    if lhs.turnMode != rhs.turnMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSTBTMatchInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TBTMatchInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.keyPoints)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyPoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSTBTMatchInfo, rhs: CRSTBTMatchInfo) -> Bool {
    if lhs.keyPoints != rhs.keyPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSTBTMatchWaypointInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TBTMatchWaypointInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "waypoints"),
    2: .standard(proto: "match_info"),
    5: .standard(proto: "match_uuid"),
  ]

  fileprivate class _StorageClass {
    var _waypoints: [CRSCoordinate] = []
    var _matchInfo: CRSTBTMatchInfo? = nil
    var _matchUuid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _waypoints = source._waypoints
      _matchInfo = source._matchInfo
      _matchUuid = source._matchUuid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._waypoints)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._matchInfo)
        case 5: try decoder.decodeSingularStringField(value: &_storage._matchUuid)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._waypoints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._waypoints, fieldNumber: 1)
      }
      if let v = _storage._matchInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._matchUuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._matchUuid, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSTBTMatchWaypointInfo, rhs: CRSTBTMatchWaypointInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._waypoints != rhs_storage._waypoints {return false}
        if _storage._matchInfo != rhs_storage._matchInfo {return false}
        if _storage._matchUuid != rhs_storage._matchUuid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSTBTMatchParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TBTMatchParam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ori_path"),
    2: .standard(proto: "tbt_points"),
    3: .standard(proto: "tbt_count"),
    4: .standard(proto: "match_trk_bias"),
    5: .standard(proto: "match_info"),
    6: .standard(proto: "api_type"),
    7: .standard(proto: "match_uuid"),
    8: .standard(proto: "match_heading_bias"),
  ]

  fileprivate class _StorageClass {
    var _oriPath: CRSRoutePath? = nil
    var _tbtPoints: [CRSRoutePoint] = []
    var _tbtCount: UInt32 = 0
    var _matchTrkBias: UInt32 = 0
    var _matchInfo: CRSTBTMatchInfo? = nil
    var _apiType: UInt32 = 0
    var _matchUuid: String = String()
    var _matchHeadingBias: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _oriPath = source._oriPath
      _tbtPoints = source._tbtPoints
      _tbtCount = source._tbtCount
      _matchTrkBias = source._matchTrkBias
      _matchInfo = source._matchInfo
      _apiType = source._apiType
      _matchUuid = source._matchUuid
      _matchHeadingBias = source._matchHeadingBias
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._oriPath)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._tbtPoints)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._tbtCount)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._matchTrkBias)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._matchInfo)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._apiType)
        case 7: try decoder.decodeSingularStringField(value: &_storage._matchUuid)
        case 8: try decoder.decodeSingularUInt32Field(value: &_storage._matchHeadingBias)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._oriPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._tbtPoints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tbtPoints, fieldNumber: 2)
      }
      if _storage._tbtCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._tbtCount, fieldNumber: 3)
      }
      if _storage._matchTrkBias != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._matchTrkBias, fieldNumber: 4)
      }
      if let v = _storage._matchInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._apiType != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiType, fieldNumber: 6)
      }
      if !_storage._matchUuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._matchUuid, fieldNumber: 7)
      }
      if _storage._matchHeadingBias != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._matchHeadingBias, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSTBTMatchParam, rhs: CRSTBTMatchParam) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._oriPath != rhs_storage._oriPath {return false}
        if _storage._tbtPoints != rhs_storage._tbtPoints {return false}
        if _storage._tbtCount != rhs_storage._tbtCount {return false}
        if _storage._matchTrkBias != rhs_storage._matchTrkBias {return false}
        if _storage._matchInfo != rhs_storage._matchInfo {return false}
        if _storage._apiType != rhs_storage._apiType {return false}
        if _storage._matchUuid != rhs_storage._matchUuid {return false}
        if _storage._matchHeadingBias != rhs_storage._matchHeadingBias {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSRoutePathCorrection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RoutePathCorrection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "param"),
    2: .standard(proto: "correction_id"),
    3: .standard(proto: "server_correction_type"),
    4: .standard(proto: "ori_end_index"),
    5: .same(proto: "distance"),
    6: .standard(proto: "corrected_path_datas"),
    7: .standard(proto: "ori_path_datas"),
    23: .standard(proto: "err_code"),
    24: .same(proto: "timestamp"),
  ]

  fileprivate class _StorageClass {
    var _param: CRSRoutePathCorrectionParam? = nil
    var _correctionID: UInt64 = 0
    var _serverCorrectionType: CRSRouteCorrectionType = .correctRoute
    var _oriEndIndex: Int32 = 0
    var _distance: UInt64 = 0
    var _correctedPathDatas: [CRSRoutePoint] = []
    var _oriPathDatas: Data = SwiftProtobuf.Internal.emptyData
    var _errCode: UInt32 = 0
    var _timestamp: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _param = source._param
      _correctionID = source._correctionID
      _serverCorrectionType = source._serverCorrectionType
      _oriEndIndex = source._oriEndIndex
      _distance = source._distance
      _correctedPathDatas = source._correctedPathDatas
      _oriPathDatas = source._oriPathDatas
      _errCode = source._errCode
      _timestamp = source._timestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._param)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._correctionID)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._serverCorrectionType)
        case 4: try decoder.decodeSingularSInt32Field(value: &_storage._oriEndIndex)
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._distance)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._correctedPathDatas)
        case 7: try decoder.decodeSingularBytesField(value: &_storage._oriPathDatas)
        case 23: try decoder.decodeSingularUInt32Field(value: &_storage._errCode)
        case 24: try decoder.decodeSingularUInt64Field(value: &_storage._timestamp)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._param {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._correctionID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._correctionID, fieldNumber: 2)
      }
      if _storage._serverCorrectionType != .correctRoute {
        try visitor.visitSingularEnumField(value: _storage._serverCorrectionType, fieldNumber: 3)
      }
      if _storage._oriEndIndex != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._oriEndIndex, fieldNumber: 4)
      }
      if _storage._distance != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._distance, fieldNumber: 5)
      }
      if !_storage._correctedPathDatas.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._correctedPathDatas, fieldNumber: 6)
      }
      if !_storage._oriPathDatas.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._oriPathDatas, fieldNumber: 7)
      }
      if _storage._errCode != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._errCode, fieldNumber: 23)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timestamp, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSRoutePathCorrection, rhs: CRSRoutePathCorrection) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._param != rhs_storage._param {return false}
        if _storage._correctionID != rhs_storage._correctionID {return false}
        if _storage._serverCorrectionType != rhs_storage._serverCorrectionType {return false}
        if _storage._oriEndIndex != rhs_storage._oriEndIndex {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._correctedPathDatas != rhs_storage._correctedPathDatas {return false}
        if _storage._oriPathDatas != rhs_storage._oriPathDatas {return false}
        if _storage._errCode != rhs_storage._errCode {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSRoutePathCorrectionParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RoutePathCorrectionParam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "track_id"),
    2: .standard(proto: "track_version"),
    3: .standard(proto: "route_direction_type"),
    4: .standard(proto: "direction_start_time"),
    5: .standard(proto: "sport_type"),
    6: .standard(proto: "correction_type"),
    7: .standard(proto: "parent_correction_id"),
    8: .standard(proto: "ori_start_index"),
    9: .standard(proto: "spec_coords"),
    10: .standard(proto: "dest_point"),
  ]

  fileprivate class _StorageClass {
    var _trackID: UInt64 = 0
    var _trackVersion: UInt32 = 0
    var _routeDirectionType: CRSRouteDirectionType = .trackDirection
    var _directionStartTime: UInt64 = 0
    var _sportType: UInt32 = 0
    var _correctionType: CRSRouteCorrectionType = .correctRoute
    var _parentCorrectionID: UInt64 = 0
    var _oriStartIndex: UInt32 = 0
    var _specCoords: [CRSCoordinate] = []
    var _destPoint: CRSCoordinate? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _trackID = source._trackID
      _trackVersion = source._trackVersion
      _routeDirectionType = source._routeDirectionType
      _directionStartTime = source._directionStartTime
      _sportType = source._sportType
      _correctionType = source._correctionType
      _parentCorrectionID = source._parentCorrectionID
      _oriStartIndex = source._oriStartIndex
      _specCoords = source._specCoords
      _destPoint = source._destPoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._trackID)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._trackVersion)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._routeDirectionType)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._directionStartTime)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._sportType)
        case 6: try decoder.decodeSingularEnumField(value: &_storage._correctionType)
        case 7: try decoder.decodeSingularUInt64Field(value: &_storage._parentCorrectionID)
        case 8: try decoder.decodeSingularUInt32Field(value: &_storage._oriStartIndex)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._specCoords)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._destPoint)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._trackID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._trackID, fieldNumber: 1)
      }
      if _storage._trackVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._trackVersion, fieldNumber: 2)
      }
      if _storage._routeDirectionType != .trackDirection {
        try visitor.visitSingularEnumField(value: _storage._routeDirectionType, fieldNumber: 3)
      }
      if _storage._directionStartTime != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._directionStartTime, fieldNumber: 4)
      }
      if _storage._sportType != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sportType, fieldNumber: 5)
      }
      if _storage._correctionType != .correctRoute {
        try visitor.visitSingularEnumField(value: _storage._correctionType, fieldNumber: 6)
      }
      if _storage._parentCorrectionID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._parentCorrectionID, fieldNumber: 7)
      }
      if _storage._oriStartIndex != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._oriStartIndex, fieldNumber: 8)
      }
      if !_storage._specCoords.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._specCoords, fieldNumber: 9)
      }
      if let v = _storage._destPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSRoutePathCorrectionParam, rhs: CRSRoutePathCorrectionParam) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._trackID != rhs_storage._trackID {return false}
        if _storage._trackVersion != rhs_storage._trackVersion {return false}
        if _storage._routeDirectionType != rhs_storage._routeDirectionType {return false}
        if _storage._directionStartTime != rhs_storage._directionStartTime {return false}
        if _storage._sportType != rhs_storage._sportType {return false}
        if _storage._correctionType != rhs_storage._correctionType {return false}
        if _storage._parentCorrectionID != rhs_storage._parentCorrectionID {return false}
        if _storage._oriStartIndex != rhs_storage._oriStartIndex {return false}
        if _storage._specCoords != rhs_storage._specCoords {return false}
        if _storage._destPoint != rhs_storage._destPoint {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSRouteCorrectionSendBspData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteCorrectionSendBspData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "correction_code"),
    2: .standard(proto: "route_correction_info"),
    3: .standard(proto: "route_correction_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.correctionCode)
      case 2: try decoder.decodeSingularBytesField(value: &self.routeCorrectionInfo)
      case 3: try decoder.decodeSingularBytesField(value: &self.routeCorrectionData)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.correctionCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.correctionCode, fieldNumber: 1)
    }
    if !self.routeCorrectionInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.routeCorrectionInfo, fieldNumber: 2)
    }
    if !self.routeCorrectionData.isEmpty {
      try visitor.visitSingularBytesField(value: self.routeCorrectionData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSRouteCorrectionSendBspData, rhs: CRSRouteCorrectionSendBspData) -> Bool {
    if lhs.correctionCode != rhs.correctionCode {return false}
    if lhs.routeCorrectionInfo != rhs.routeCorrectionInfo {return false}
    if lhs.routeCorrectionData != rhs.routeCorrectionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSTrackClimbLevelItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrackClimbLevelItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_distance"),
    2: .standard(proto: "end_distance"),
    3: .standard(proto: "start_index"),
    4: .standard(proto: "end_index"),
    5: .standard(proto: "slope_level"),
    6: .standard(proto: "avg_slope"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.startDistance)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.endDistance)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.startIndex)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.endIndex)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.slopeLevel)
      case 6: try decoder.decodeSingularInt32Field(value: &self.avgSlope)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startDistance != 0 {
      try visitor.visitSingularUInt32Field(value: self.startDistance, fieldNumber: 1)
    }
    if self.endDistance != 0 {
      try visitor.visitSingularUInt32Field(value: self.endDistance, fieldNumber: 2)
    }
    if self.startIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.startIndex, fieldNumber: 3)
    }
    if self.endIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.endIndex, fieldNumber: 4)
    }
    if self.slopeLevel != 0 {
      try visitor.visitSingularUInt32Field(value: self.slopeLevel, fieldNumber: 5)
    }
    if self.avgSlope != 0 {
      try visitor.visitSingularInt32Field(value: self.avgSlope, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSTrackClimbLevelItem, rhs: CRSTrackClimbLevelItem) -> Bool {
    if lhs.startDistance != rhs.startDistance {return false}
    if lhs.endDistance != rhs.endDistance {return false}
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.endIndex != rhs.endIndex {return false}
    if lhs.slopeLevel != rhs.slopeLevel {return false}
    if lhs.avgSlope != rhs.avgSlope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSTrackClimbProItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrackClimbProItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_distance"),
    2: .standard(proto: "end_distance"),
    3: .standard(proto: "start_index"),
    4: .standard(proto: "end_index"),
    5: .standard(proto: "avg_slope"),
    6: .standard(proto: "elev_gain"),
    7: .standard(proto: "start_level_index"),
    8: .standard(proto: "end_level_index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.startDistance)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.endDistance)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.startIndex)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.endIndex)
      case 5: try decoder.decodeSingularInt32Field(value: &self.avgSlope)
      case 6: try decoder.decodeSingularInt32Field(value: &self.elevGain)
      case 7: try decoder.decodeSingularUInt32Field(value: &self.startLevelIndex)
      case 8: try decoder.decodeSingularUInt32Field(value: &self.endLevelIndex)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startDistance != 0 {
      try visitor.visitSingularUInt32Field(value: self.startDistance, fieldNumber: 1)
    }
    if self.endDistance != 0 {
      try visitor.visitSingularUInt32Field(value: self.endDistance, fieldNumber: 2)
    }
    if self.startIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.startIndex, fieldNumber: 3)
    }
    if self.endIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.endIndex, fieldNumber: 4)
    }
    if self.avgSlope != 0 {
      try visitor.visitSingularInt32Field(value: self.avgSlope, fieldNumber: 5)
    }
    if self.elevGain != 0 {
      try visitor.visitSingularInt32Field(value: self.elevGain, fieldNumber: 6)
    }
    if self.startLevelIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.startLevelIndex, fieldNumber: 7)
    }
    if self.endLevelIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.endLevelIndex, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSTrackClimbProItem, rhs: CRSTrackClimbProItem) -> Bool {
    if lhs.startDistance != rhs.startDistance {return false}
    if lhs.endDistance != rhs.endDistance {return false}
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.endIndex != rhs.endIndex {return false}
    if lhs.avgSlope != rhs.avgSlope {return false}
    if lhs.elevGain != rhs.elevGain {return false}
    if lhs.startLevelIndex != rhs.startLevelIndex {return false}
    if lhs.endLevelIndex != rhs.endLevelIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CRSTrackClimbInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrackClimbInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slope_level_arr"),
    2: .standard(proto: "climb_pro_arr"),
    3: .standard(proto: "avg_slope"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.slopeLevelArr)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.climbProArr)
      case 3: try decoder.decodeSingularInt32Field(value: &self.avgSlope)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.slopeLevelArr.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slopeLevelArr, fieldNumber: 1)
    }
    if !self.climbProArr.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.climbProArr, fieldNumber: 2)
    }
    if self.avgSlope != 0 {
      try visitor.visitSingularInt32Field(value: self.avgSlope, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CRSTrackClimbInfo, rhs: CRSTrackClimbInfo) -> Bool {
    if lhs.slopeLevelArr != rhs.slopeLevelArr {return false}
    if lhs.climbProArr != rhs.climbProArr {return false}
    if lhs.avgSlope != rhs.avgSlope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
